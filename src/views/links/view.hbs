
<div class="container">


   <h1 class="row header">Monitor de signos vitales </h1>

   <div id="signal" class="row">
      <div class="col-sm-8 " id="target"></div>


      <div class="col-sm-2 p-4 ">
         <div class="row p-2" style="background-color:rgb(6, 52, 70);">

            <div class="card" id="card"
               style="color: blue; background-color: rgb(2, 27, 37);text-shadow: 1px 1px 2px black, 0 0 1em blue, 0 0 0.2em blue;">
               <h5>Pulse</h5>
               <h6>BPM</h6>
               <div class="card-body text-center">

                  <h1 id="pl">1</h1>


               </div>

            </div>

         </div>

         <div class="row p-2" style="background-color: rgb(6, 52, 70);">

            <div class="card" id="card"
               style="color: green; background-color: rgb(2, 27, 37);text-shadow: 1px 1px 2px black, 0 0 1em blue, 0 0 0.2em green;">
               <h5>Sp02</h5>
               <h6>% blood oxygen saturation</h6>
               <div class="card-body text-center">

                  <h1 id="sp">2</h1>

               </div>

            </div>

         </div>


         <div class="row p-2" style="background-color:rgb(6, 52, 70);">

            <div class="card" id="card"
               style="color: rgb(224, 13, 13); background-color: rgb(2, 27, 37); text-shadow: 1px 1px 2px black, 0 0 1em blue, 0 0 0.2em red;">
               <h5>Respiration</h5>
               <h6>RPM</h6>
               <div class="card-body text-center">

                  <h1 id="rp">3</h1>


               </div>

            </div>

         </div>

      </div>






   </div>



</div>






<script src="https://unpkg.com/@arction/lcjs@3.4.0/dist/lcjs.iife.js"></script>

<script src="https://unpkg.com/@arction/xydata@1.4.0/dist/xydata.iife.js"></script>
<script>


   const ecgdata = {{ encodeMyString data.ecg }}
   const ppgdata = {{ encodeMyString data.ppg }}
   const respdata = {{ encodeMyString data.resp }}
   const spo2data = {{ encodeMyString data.spo2 }}
   const pulsdata = {{ encodeMyString data.puls }}
   const rpdata = {{ encodeMyString data.rp }}




   const {
      lightningChart,
      AxisScrollStrategies,
      Themes,
      UIElementBuilders,
      UILayoutBuilders,
   } = lcjs


   const {
      createProgressiveRandomGenerator,
      createSampledDataGenerator
   } = xydata


   const channels = [
      {
         shortName: "ECG/EKG",
         name: "Electrocardiogram",
         dataSet: ecgdata,
         color: "#00ff00",
         yStart: -1955,
         yEnd: 1195,
      },
      {
         shortName: "PPG",
         name: "photoplethysmogram",
         dataSet: ppgdata,
         color: "#00ff00",
         yStart: -1955,
         yEnd: 1195,
      },
      {
         shortName: "RESP",
         name: "rib cage",
         dataSet: respdata,
         color: "#00ff00",
         yStart: -1955,
         yEnd: 1195,
      },
   ];

   const dashboard = lightningChart()
      .Dashboard({
         numberOfRows: channels.length,
         numberOfColumns: 1,
         theme: Themes.auroraBorealis,
         container: 'target',
      })



   const chart1 = dashboard.createChartXY({
      columnIndex: 0,
      rowIndex: 0,
      columnSpan: 1,
      rowSpan: 1
   })
   const chart2 = dashboard.createChartXY({
      columnIndex: 0,
      rowIndex: 1,
      columnSpan: 1,
      rowSpan: 1
   })

   const chart3 = dashboard.createChartXY({
      columnIndex: 0,
      rowIndex: 2,
      columnSpan: 1,
      rowSpan: 1
   })


   chart1.setTitle('ECG/EKG')
   chart1.getDefaultAxisY()
      .setTitle('mV')
      .setInterval(0, 1)
      .setScrollStrategy(AxisScrollStrategies.expansion)

   chart1.getDefaultAxisX()
      .setTitle('miliseconds')
      .setInterval(0, 600)
      .setScrollStrategy(AxisScrollStrategies.progressive)

   const series1 = chart1.addLineSeries({
      dataPattern: {

         pattern: 'ProgressiveX',

         regularProgressiveStep: true,
      }
   })



   createSampledDataGenerator(ecgdata, 1, 10)
      .setSamplingFrequency(1)
      .setInputData(ecgdata)
      .generate()
      .setStreamBatchSize(10)
      .setStreamInterval(80)
      .setStreamRepeat(true)
      .toStream()
      .forEach(ecgdata => {

         series1.add({ x: ecgdata.timestamp, y: ecgdata.data.y })
      })





   chart2.setTitle('PPG')
   chart2.getDefaultAxisY()
      .setTitle('mV')
      .setInterval(0, 1.5)
      .setScrollStrategy(AxisScrollStrategies.expansion)

   chart2.getDefaultAxisX()
      .setTitle('miliseconds')
      .setInterval(0, 600)
      .setScrollStrategy(AxisScrollStrategies.progressive)


   const series2 = chart2.addLineSeries({
      dataPattern: {

         pattern: 'ProgressiveX',

         regularProgressiveStep: true,
      }
   })



   createSampledDataGenerator(ppgdata, 1, 10)
      .setSamplingFrequency(1)
      .setInputData(ppgdata)
      .generate()
      .setStreamBatchSize(10)
      .setStreamInterval(80)
      .setStreamRepeat(true)
      .toStream()
      .forEach(ppgdata => {

         series2.add({ x: ppgdata.timestamp, y: ppgdata.data.y })
      })


   chart3.setTitle('RESP')
   chart3.getDefaultAxisY()
      .setTitle('mV')
      .setInterval(0, 1.5)
      .setScrollStrategy(AxisScrollStrategies.expansion)

   chart3.getDefaultAxisX()
      .setTitle('miliseconds')
      .setInterval(0, 1000)
      .setScrollStrategy(AxisScrollStrategies.progressive)


   const series3 = chart3.addLineSeries({
      dataPattern: {

         pattern: 'ProgressiveX',

         regularProgressiveStep: true,
      }
   })



   createSampledDataGenerator(respdata, 1, 10)
      .setSamplingFrequency(1)
      .setInputData(respdata)
      .generate()
      .setStreamBatchSize(10)
      .setStreamInterval(50)
      .setStreamRepeat(true)
      .toStream()
      .forEach(respdata => {

         series3.add({ x: respdata.timestamp, y: respdata.data.y })
      })




   let displayIndex1 = 0;
   let displayIndex2 = 0;
   let displayIndex3 = 0;
   let time = document.getElementById('time');

   let elem1 = document.getElementById('sp');
   let elem2 = document.getElementById('pl');
   let elem3 = document.getElementById('rp');
   let delay = 1000; // 1 second delay

   setInterval(() => {
      if (elem1) {
         elem1.innerHTML = spo2data[displayIndex1];
      }
      if (elem2) {
         elem2.innerHTML = pulsdata[displayIndex2];
      }
      if (elem3) {
         elem3.innerHTML = rpdata[displayIndex3];
      }

      // Move to the next item in dialog
      displayIndex1++;
      displayIndex2++;
      displayIndex3++;


      // If display index goes out of index range, start again
      if (displayIndex1 >= spo2data.length) {
         displayIndex1 = 0;
      }
      if (displayIndex2 >= pulsdata.length) {
         displayIndex2 = 0;
      }
      if (displayIndex3 >= rpdata.length) {
         displayIndex3 = 0;
      }
   }, delay);
    /*const {
      lightningChart,
      AxisScrollStrategies,
      Themes
  } = lcjs

  // Import data-generators from 'xydata'-library.
  const {
      createSampledDataGenerator
  } = xydata

  // Create a XY Chart.
  const chart = lightningChart().ChartXY({
      theme: Themes.sunset,
      container: 'target',
  }).setTitle('ECG')

  // Create line series optimized for regular progressive X data.
  const series = chart.addLineSeries({
      dataPattern: {
          // pattern: 'ProgressiveX' => Each consecutive data point has increased X coordinate.
          pattern: 'ProgressiveX',
          // regularProgressiveStep: true => The X step between each consecutive data point is regular (for example, always `1.0`).
          regularProgressiveStep: true,
      }
  })
      // Destroy automatically outscrolled data (old data becoming out of scrolling axis range).
      // Actual data cleaning can happen at any convenient time (not necessarily immediately when data goes out of range).
      .setMaxPointCount(10000)
      .setMouseInteractions(false)


  const point = {{ encodeMyString data.ecg }}
  console.log(point)
  const resultx = point.map((obj) => Object.values(obj)[0]);
  const resulty = point.map((obj) => Object.values(obj)[1]);

  var maxX = Math.max.apply(Math, resultx);
  var minX = Math.min.apply(Math, resultx);
  var maxY = Math.max.apply(Math, resulty);
  var minY = Math.min.apply(Math, resulty);
  // Setup view nicely.
  chart.getDefaultAxisY()
      .setTitle('mV')
      .setInterval(minY - 0.10, maxY + 0.10)
      .setScrollStrategy(AxisScrollStrategies.expansion)

  chart.getDefaultAxisX()
      .setTitle('milliseconds')
      .setInterval(minX, 3000)
      .setScrollStrategy(AxisScrollStrategies.progressive)



  createSampledDataGenerator(point, 1, 10)
      .setSamplingFrequency(1)
      .setInputData(point)
      .generate()
      .setStreamBatchSize(48)
      .setStreamInterval(50)
      .setStreamRepeat(true)
      .toStream()
      .forEach(point => {
          // Push the created points to the series.
          series.add({ x: point.timestamp, y: point.data.y })
      })*/

</script>